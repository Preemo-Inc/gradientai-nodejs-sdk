/* tslint:disable */
/* eslint-disable */
/**
 * Gradient AI API
 * Interface for interacting with Gradient AI.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@gradient.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
import FormData = require("form-data");
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddFilesToRagCollectionBodyParams
 */
export interface AddFilesToRagCollectionBodyParams {
    /**
     * 
     * @type {Array<CreateRagCollectionBodyParamsFilesInner>}
     * @memberof AddFilesToRagCollectionBodyParams
     */
    'files': Array<CreateRagCollectionBodyParamsFilesInner>;
}
/**
 * 
 * @export
 * @interface AddFilesToRagCollectionError
 */
export interface AddFilesToRagCollectionError {
    /**
     * 
     * @type {string}
     * @memberof AddFilesToRagCollectionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AnalyzeSentimentBodyParams
 */
export interface AnalyzeSentimentBodyParams {
    /**
     * The document that will be analyzed to determine the sentiment.
     * @type {string}
     * @memberof AnalyzeSentimentBodyParams
     */
    'document': string;
    /**
     * Example pairs of documents and sentiments.
     * @type {Array<AnalyzeSentimentBodyParamsExamplesInner>}
     * @memberof AnalyzeSentimentBodyParams
     */
    'examples'?: Array<AnalyzeSentimentBodyParamsExamplesInner> | null;
}
/**
 * 
 * @export
 * @interface AnalyzeSentimentBodyParamsExamplesInner
 */
export interface AnalyzeSentimentBodyParamsExamplesInner {
    /**
     * 
     * @type {string}
     * @memberof AnalyzeSentimentBodyParamsExamplesInner
     */
    'document': string;
    /**
     * 
     * @type {string}
     * @memberof AnalyzeSentimentBodyParamsExamplesInner
     */
    'sentiment': AnalyzeSentimentBodyParamsExamplesInnerSentimentEnum;
}

export const AnalyzeSentimentBodyParamsExamplesInnerSentimentEnum = {
    Negative: 'negative',
    Neutral: 'neutral',
    Positive: 'positive'
} as const;

export type AnalyzeSentimentBodyParamsExamplesInnerSentimentEnum = typeof AnalyzeSentimentBodyParamsExamplesInnerSentimentEnum[keyof typeof AnalyzeSentimentBodyParamsExamplesInnerSentimentEnum];

/**
 * 
 * @export
 * @interface AnalyzeSentimentError
 */
export interface AnalyzeSentimentError {
    /**
     * 
     * @type {string}
     * @memberof AnalyzeSentimentError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AnalyzeSentimentSuccess
 */
export interface AnalyzeSentimentSuccess {
    /**
     * 
     * @type {string}
     * @memberof AnalyzeSentimentSuccess
     */
    'sentiment': AnalyzeSentimentSuccessSentimentEnum;
}

export const AnalyzeSentimentSuccessSentimentEnum = {
    Negative: 'negative',
    Neutral: 'neutral',
    Positive: 'positive'
} as const;

export type AnalyzeSentimentSuccessSentimentEnum = typeof AnalyzeSentimentSuccessSentimentEnum[keyof typeof AnalyzeSentimentSuccessSentimentEnum];

/**
 * 
 * @export
 * @interface BaseModel
 */
export interface BaseModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseModel
     */
    'capabilities': Array<BaseModelCapabilitiesEnum>;
    /**
     * 
     * @type {string}
     * @memberof BaseModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseModel
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof BaseModel
     */
    'type': BaseModelTypeEnum;
}

export const BaseModelCapabilitiesEnum = {
    Complete: 'complete',
    FineTune: 'fineTune'
} as const;

export type BaseModelCapabilitiesEnum = typeof BaseModelCapabilitiesEnum[keyof typeof BaseModelCapabilitiesEnum];
export const BaseModelTypeEnum = {
    BaseModel: 'baseModel'
} as const;

export type BaseModelTypeEnum = typeof BaseModelTypeEnum[keyof typeof BaseModelTypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelBodyParams
 */
export interface CompleteModelBodyParams {
    /**
     * Automatically adds the recommended base model templating.
     * @type {boolean}
     * @memberof CompleteModelBodyParams
     */
    'autoTemplate'?: boolean | null;
    /**
     * 
     * @type {CompleteModelBodyParamsGuidance}
     * @memberof CompleteModelBodyParams
     */
    'guidance'?: CompleteModelBodyParamsGuidance | null;
    /**
     * The maximum number of tokens to generate.
     * @type {number}
     * @memberof CompleteModelBodyParams
     */
    'maxGeneratedTokenCount'?: number | null;
    /**
     * The prompt string you are providing the model, to which the model will generate a completion in response.
     * @type {string}
     * @memberof CompleteModelBodyParams
     */
    'query': string;
    /**
     * 
     * @type {CompleteModelBodyParamsRag}
     * @memberof CompleteModelBodyParams
     */
    'rag'?: CompleteModelBodyParamsRag | null;
    /**
     * This parameter adjusts the degree of randomness in generation. Higher temperature results in more diverse generations.
     * @type {number}
     * @memberof CompleteModelBodyParams
     */
    'temperature'?: number | null;
    /**
     * This parameter ensures that only the top k most likely tokens are considered for generation at each step.
     * @type {number}
     * @memberof CompleteModelBodyParams
     */
    'topK'?: number | null;
    /**
     * This parameter ensures that only the most likely tokens, with total probability mass of p, are considered for generation at each step. If topK is also enabled, topP acts after topK.
     * @type {number}
     * @memberof CompleteModelBodyParams
     */
    'topP'?: number | null;
}
/**
 * 
 * @export
 * @interface CompleteModelBodyParamsGuidance
 */
export interface CompleteModelBodyParamsGuidance {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelBodyParamsGuidance
     */
    'type': CompleteModelBodyParamsGuidanceTypeEnum;
    /**
     * The set of possible values that should be generated by the model
     * @type {Array<string>}
     * @memberof CompleteModelBodyParamsGuidance
     */
    'value': Array<string>;
}

export const CompleteModelBodyParamsGuidanceTypeEnum = {
    Choice: 'choice'
} as const;

export type CompleteModelBodyParamsGuidanceTypeEnum = typeof CompleteModelBodyParamsGuidanceTypeEnum[keyof typeof CompleteModelBodyParamsGuidanceTypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelBodyParamsRag
 */
export interface CompleteModelBodyParamsRag {
    /**
     * The ID of the RAG collection to retrieve context from before running completion
     * @type {string}
     * @memberof CompleteModelBodyParamsRag
     */
    'collectionId': string;
}
/**
 * @type CompleteModelError
 * @export
 */
export type CompleteModelError = CompleteModelErrorOneOf | CompleteModelErrorOneOf1 | CompleteModelErrorOneOf10 | CompleteModelErrorOneOf2 | CompleteModelErrorOneOf3 | CompleteModelErrorOneOf4 | CompleteModelErrorOneOf5 | CompleteModelErrorOneOf6 | CompleteModelErrorOneOf7 | CompleteModelErrorOneOf8 | CompleteModelErrorOneOf9;

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf
 */
export interface CompleteModelErrorOneOf {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf
     */
    'message': string;
    /**
     * 
     * @type {CompleteModelErrorOneOfPayload}
     * @memberof CompleteModelErrorOneOf
     */
    'payload': CompleteModelErrorOneOfPayload;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf
     */
    'type': CompleteModelErrorOneOfTypeEnum;
}

export const CompleteModelErrorOneOfTypeEnum = {
    FlaggedContent: 'flaggedContent',
    BodyParsingError: 'bodyParsingError',
    QueryOrPathParsingError: 'queryOrPathParsingError',
    Failed: 'failed',
    ModelDoesNotSupportGuidance: 'modelDoesNotSupportGuidance',
    NoRagDocumentsFound: 'noRagDocumentsFound',
    RagRequiresAutoTemplating: 'ragRequiresAutoTemplating',
    UnknownBaseModel: 'unknownBaseModel',
    UnknownModelAdapter: 'unknownModelAdapter',
    UnknownRagCollection: 'unknownRagCollection',
    UnprocessableContent: 'unprocessableContent'
} as const;

export type CompleteModelErrorOneOfTypeEnum = typeof CompleteModelErrorOneOfTypeEnum[keyof typeof CompleteModelErrorOneOfTypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf1
 */
export interface CompleteModelErrorOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf1
     */
    'message': string;
    /**
     * 
     * @type {CompleteModelErrorOneOf1Payload}
     * @memberof CompleteModelErrorOneOf1
     */
    'payload': CompleteModelErrorOneOf1Payload;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf1
     */
    'type': CompleteModelErrorOneOf1TypeEnum;
}

export const CompleteModelErrorOneOf1TypeEnum = {
    BodyParsingError: 'bodyParsingError',
    FlaggedContent: 'flaggedContent',
    QueryOrPathParsingError: 'queryOrPathParsingError',
    Failed: 'failed',
    ModelDoesNotSupportGuidance: 'modelDoesNotSupportGuidance',
    NoRagDocumentsFound: 'noRagDocumentsFound',
    RagRequiresAutoTemplating: 'ragRequiresAutoTemplating',
    UnknownBaseModel: 'unknownBaseModel',
    UnknownModelAdapter: 'unknownModelAdapter',
    UnknownRagCollection: 'unknownRagCollection',
    UnprocessableContent: 'unprocessableContent',
    ModelIncapableOfFineTuning: 'modelIncapableOfFineTuning',
    NanLoss: 'nanLoss'
} as const;

export type CompleteModelErrorOneOf1TypeEnum = typeof CompleteModelErrorOneOf1TypeEnum[keyof typeof CompleteModelErrorOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf10
 */
export interface CompleteModelErrorOneOf10 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf10
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf10
     */
    'type': CompleteModelErrorOneOf10TypeEnum;
}

export const CompleteModelErrorOneOf10TypeEnum = {
    UnprocessableContent: 'unprocessableContent'
} as const;

export type CompleteModelErrorOneOf10TypeEnum = typeof CompleteModelErrorOneOf10TypeEnum[keyof typeof CompleteModelErrorOneOf10TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf1Payload
 */
export interface CompleteModelErrorOneOf1Payload {
    /**
     * 
     * @type {any}
     * @memberof CompleteModelErrorOneOf1Payload
     */
    'formattedValidationError'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof CompleteModelErrorOneOf1Payload
     */
    'validationError'?: any;
}
/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf2
 */
export interface CompleteModelErrorOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf2
     */
    'message': string;
    /**
     * 
     * @type {CompleteModelErrorOneOf1Payload}
     * @memberof CompleteModelErrorOneOf2
     */
    'payload': CompleteModelErrorOneOf1Payload;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf2
     */
    'type': CompleteModelErrorOneOf2TypeEnum;
}

export const CompleteModelErrorOneOf2TypeEnum = {
    QueryOrPathParsingError: 'queryOrPathParsingError'
} as const;

export type CompleteModelErrorOneOf2TypeEnum = typeof CompleteModelErrorOneOf2TypeEnum[keyof typeof CompleteModelErrorOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf3
 */
export interface CompleteModelErrorOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf3
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf3
     */
    'type': CompleteModelErrorOneOf3TypeEnum;
}

export const CompleteModelErrorOneOf3TypeEnum = {
    Failed: 'failed'
} as const;

export type CompleteModelErrorOneOf3TypeEnum = typeof CompleteModelErrorOneOf3TypeEnum[keyof typeof CompleteModelErrorOneOf3TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf4
 */
export interface CompleteModelErrorOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf4
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf4
     */
    'type': CompleteModelErrorOneOf4TypeEnum;
}

export const CompleteModelErrorOneOf4TypeEnum = {
    ModelDoesNotSupportGuidance: 'modelDoesNotSupportGuidance'
} as const;

export type CompleteModelErrorOneOf4TypeEnum = typeof CompleteModelErrorOneOf4TypeEnum[keyof typeof CompleteModelErrorOneOf4TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf5
 */
export interface CompleteModelErrorOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf5
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf5
     */
    'type': CompleteModelErrorOneOf5TypeEnum;
}

export const CompleteModelErrorOneOf5TypeEnum = {
    NoRagDocumentsFound: 'noRagDocumentsFound'
} as const;

export type CompleteModelErrorOneOf5TypeEnum = typeof CompleteModelErrorOneOf5TypeEnum[keyof typeof CompleteModelErrorOneOf5TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf6
 */
export interface CompleteModelErrorOneOf6 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf6
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf6
     */
    'type': CompleteModelErrorOneOf6TypeEnum;
}

export const CompleteModelErrorOneOf6TypeEnum = {
    RagRequiresAutoTemplating: 'ragRequiresAutoTemplating'
} as const;

export type CompleteModelErrorOneOf6TypeEnum = typeof CompleteModelErrorOneOf6TypeEnum[keyof typeof CompleteModelErrorOneOf6TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf7
 */
export interface CompleteModelErrorOneOf7 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf7
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf7
     */
    'type': CompleteModelErrorOneOf7TypeEnum;
}

export const CompleteModelErrorOneOf7TypeEnum = {
    UnknownBaseModel: 'unknownBaseModel'
} as const;

export type CompleteModelErrorOneOf7TypeEnum = typeof CompleteModelErrorOneOf7TypeEnum[keyof typeof CompleteModelErrorOneOf7TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf8
 */
export interface CompleteModelErrorOneOf8 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf8
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf8
     */
    'type': CompleteModelErrorOneOf8TypeEnum;
}

export const CompleteModelErrorOneOf8TypeEnum = {
    UnknownModelAdapter: 'unknownModelAdapter'
} as const;

export type CompleteModelErrorOneOf8TypeEnum = typeof CompleteModelErrorOneOf8TypeEnum[keyof typeof CompleteModelErrorOneOf8TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOf9
 */
export interface CompleteModelErrorOneOf9 {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf9
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOf9
     */
    'type': CompleteModelErrorOneOf9TypeEnum;
}

export const CompleteModelErrorOneOf9TypeEnum = {
    UnknownRagCollection: 'unknownRagCollection'
} as const;

export type CompleteModelErrorOneOf9TypeEnum = typeof CompleteModelErrorOneOf9TypeEnum[keyof typeof CompleteModelErrorOneOf9TypeEnum];

/**
 * 
 * @export
 * @interface CompleteModelErrorOneOfPayload
 */
export interface CompleteModelErrorOneOfPayload {
    /**
     * 
     * @type {Array<CompleteModelErrorOneOfPayloadFlaggedContentInner>}
     * @memberof CompleteModelErrorOneOfPayload
     */
    'flaggedContent': Array<CompleteModelErrorOneOfPayloadFlaggedContentInner>;
}
/**
 * 
 * @export
 * @interface CompleteModelErrorOneOfPayloadFlaggedContentInner
 */
export interface CompleteModelErrorOneOfPayloadFlaggedContentInner {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelErrorOneOfPayloadFlaggedContentInner
     */
    'sample': string;
}
/**
 * 
 * @export
 * @interface CompleteModelSuccess
 */
export interface CompleteModelSuccess {
    /**
     * 
     * @type {string}
     * @memberof CompleteModelSuccess
     */
    'finishReason': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteModelSuccess
     */
    'generatedOutput': string;
}
/**
 * 
 * @export
 * @interface CreateAudioTranscriptionBodyParams
 */
export interface CreateAudioTranscriptionBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateAudioTranscriptionBodyParams
     */
    'fileId': string;
}
/**
 * 
 * @export
 * @interface CreateAudioTranscriptionError
 */
export interface CreateAudioTranscriptionError {
    /**
     * 
     * @type {string}
     * @memberof CreateAudioTranscriptionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateAudioTranscriptionSuccess
 */
export interface CreateAudioTranscriptionSuccess {
    /**
     * 
     * @type {string}
     * @memberof CreateAudioTranscriptionSuccess
     */
    'transcriptionId': string;
}
/**
 * 
 * @export
 * @interface CreateModelBodyParams
 */
export interface CreateModelBodyParams {
    /**
     * 
     * @type {CreateModelBodyParamsInitialHyperparameters}
     * @memberof CreateModelBodyParams
     */
    'initialHyperparameters'?: CreateModelBodyParamsInitialHyperparameters | null;
    /**
     * 
     * @type {CreateModelBodyParamsModel}
     * @memberof CreateModelBodyParams
     */
    'model': CreateModelBodyParamsModel;
}
/**
 * 
 * @export
 * @interface CreateModelBodyParamsInitialHyperparameters
 */
export interface CreateModelBodyParamsInitialHyperparameters {
    /**
     * 
     * @type {CreateModelBodyParamsInitialHyperparametersLoraHyperparameters}
     * @memberof CreateModelBodyParamsInitialHyperparameters
     */
    'loraHyperparameters'?: CreateModelBodyParamsInitialHyperparametersLoraHyperparameters | null;
    /**
     * 
     * @type {CreateModelBodyParamsInitialHyperparametersTrainingArguments}
     * @memberof CreateModelBodyParamsInitialHyperparameters
     */
    'trainingArguments'?: CreateModelBodyParamsInitialHyperparametersTrainingArguments | null;
}
/**
 * 
 * @export
 * @interface CreateModelBodyParamsInitialHyperparametersLoraHyperparameters
 */
export interface CreateModelBodyParamsInitialHyperparametersLoraHyperparameters {
    /**
     * 
     * @type {number}
     * @memberof CreateModelBodyParamsInitialHyperparametersLoraHyperparameters
     */
    'rank'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateModelBodyParamsInitialHyperparametersTrainingArguments
 */
export interface CreateModelBodyParamsInitialHyperparametersTrainingArguments {
    /**
     * 
     * @type {number}
     * @memberof CreateModelBodyParamsInitialHyperparametersTrainingArguments
     */
    'learningRate'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateModelBodyParamsModel
 */
export interface CreateModelBodyParamsModel {
    /**
     * The foundational model you are creating a new instance of for fine-tuning.
     * @type {string}
     * @memberof CreateModelBodyParamsModel
     */
    'baseModelId': string;
    /**
     * What your new fine-tuned model will be called.
     * @type {string}
     * @memberof CreateModelBodyParamsModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateModelError
 */
export interface CreateModelError {
    /**
     * 
     * @type {string}
     * @memberof CreateModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateModelSuccess
 */
export interface CreateModelSuccess {
    /**
     * 
     * @type {string}
     * @memberof CreateModelSuccess
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreateRagCollectionBodyParams
 */
export interface CreateRagCollectionBodyParams {
    /**
     * 
     * @type {Array<CreateRagCollectionBodyParamsFilesInner>}
     * @memberof CreateRagCollectionBodyParams
     */
    'files'?: Array<CreateRagCollectionBodyParamsFilesInner> | null;
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionBodyParams
     */
    'name': string;
    /**
     * 
     * @type {CreateRagCollectionBodyParamsParser}
     * @memberof CreateRagCollectionBodyParams
     */
    'parser'?: CreateRagCollectionBodyParamsParser | null;
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionBodyParams
     */
    'slug': CreateRagCollectionBodyParamsSlugEnum;
}

export const CreateRagCollectionBodyParamsSlugEnum = {
    BgeLarge: 'bge-large'
} as const;

export type CreateRagCollectionBodyParamsSlugEnum = typeof CreateRagCollectionBodyParamsSlugEnum[keyof typeof CreateRagCollectionBodyParamsSlugEnum];

/**
 * 
 * @export
 * @interface CreateRagCollectionBodyParamsFilesInner
 */
export interface CreateRagCollectionBodyParamsFilesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionBodyParamsFilesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionBodyParamsFilesInner
     */
    'name': string;
}
/**
 * @type CreateRagCollectionBodyParamsParser
 * @export
 */
export type CreateRagCollectionBodyParamsParser = { parserType: 'sentenceWindowNodeParser' } & SentenceWindowNodeParser | { parserType: 'simpleNodeParser' } & SimpleNodeParser;

/**
 * 
 * @export
 * @interface CreateRagCollectionError
 */
export interface CreateRagCollectionError {
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateRagCollectionSuccess
 */
export interface CreateRagCollectionSuccess {
    /**
     * 
     * @type {string}
     * @memberof CreateRagCollectionSuccess
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteModelError
 */
export interface DeleteModelError {
    /**
     * 
     * @type {string}
     * @memberof DeleteModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteRagCollectionError
 */
export interface DeleteRagCollectionError {
    /**
     * 
     * @type {string}
     * @memberof DeleteRagCollectionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExtractEntityBodyParams
 */
export interface ExtractEntityBodyParams {
    /**
     * The document from which to extract data.
     * @type {string}
     * @memberof ExtractEntityBodyParams
     */
    'document': string;
    /**
     * The expected schema of the entity result.
     * @type {{ [key: string]: ExtractEntityBodyParamsSchemaValue; }}
     * @memberof ExtractEntityBodyParams
     */
    'schema': { [key: string]: ExtractEntityBodyParamsSchemaValue; };
}
/**
 * 
 * @export
 * @interface ExtractEntityBodyParamsSchemaValue
 */
export interface ExtractEntityBodyParamsSchemaValue {
    /**
     * 
     * @type {boolean}
     * @memberof ExtractEntityBodyParamsSchemaValue
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ExtractEntityBodyParamsSchemaValue
     */
    'type': ExtractEntityBodyParamsSchemaValueTypeEnum;
}

export const ExtractEntityBodyParamsSchemaValueTypeEnum = {
    Boolean: 'boolean',
    Number: 'number',
    String: 'string'
} as const;

export type ExtractEntityBodyParamsSchemaValueTypeEnum = typeof ExtractEntityBodyParamsSchemaValueTypeEnum[keyof typeof ExtractEntityBodyParamsSchemaValueTypeEnum];

/**
 * 
 * @export
 * @interface ExtractEntityError
 */
export interface ExtractEntityError {
    /**
     * 
     * @type {string}
     * @memberof ExtractEntityError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExtractEntitySuccess
 */
export interface ExtractEntitySuccess {
    /**
     * 
     * @type {{ [key: string]: ExtractEntitySuccessEntityValue; }}
     * @memberof ExtractEntitySuccess
     */
    'entity': { [key: string]: ExtractEntitySuccessEntityValue; };
}
/**
 * 
 * @export
 * @interface ExtractEntitySuccessEntityValue
 */
export interface ExtractEntitySuccessEntityValue {
}
/**
 * 
 * @export
 * @interface ExtractPdfError
 */
export interface ExtractPdfError {
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExtractPdfSuccess
 */
export interface ExtractPdfSuccess {
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInner>}
     * @memberof ExtractPdfSuccess
     */
    'pages': Array<ExtractPdfSuccessPagesInner>;
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccess
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccess
     */
    'title': string | null;
}
/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInner
 */
export interface ExtractPdfSuccessPagesInner {
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInnerImagesInner>}
     * @memberof ExtractPdfSuccessPagesInner
     */
    'images': Array<ExtractPdfSuccessPagesInnerImagesInner>;
    /**
     * 
     * @type {number}
     * @memberof ExtractPdfSuccessPagesInner
     */
    'pageNumber': number;
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInnerTablesInner>}
     * @memberof ExtractPdfSuccessPagesInner
     */
    'tables': Array<ExtractPdfSuccessPagesInnerTablesInner>;
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInner
     */
    'text': string;
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInnerTextBlocksInner>}
     * @memberof ExtractPdfSuccessPagesInner
     */
    'textBlocks': Array<ExtractPdfSuccessPagesInnerTextBlocksInner>;
}
/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInnerImagesInner
 */
export interface ExtractPdfSuccessPagesInnerImagesInner {
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerImagesInner
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerImagesInner
     */
    'format': ExtractPdfSuccessPagesInnerImagesInnerFormatEnum;
}

export const ExtractPdfSuccessPagesInnerImagesInnerFormatEnum = {
    Base64Png: 'base64-png'
} as const;

export type ExtractPdfSuccessPagesInnerImagesInnerFormatEnum = typeof ExtractPdfSuccessPagesInnerImagesInnerFormatEnum[keyof typeof ExtractPdfSuccessPagesInnerImagesInnerFormatEnum];

/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInnerTablesInner
 */
export interface ExtractPdfSuccessPagesInnerTablesInner {
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerTablesInner
     */
    'name': string;
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner>}
     * @memberof ExtractPdfSuccessPagesInnerTablesInner
     */
    'tableRows': Array<ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner>;
}
/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner
 */
export interface ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner {
    /**
     * 
     * @type {Array<ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner>}
     * @memberof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner
     */
    'cells': Array<ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner>;
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInner
     */
    'type': ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerTypeEnum;
}

export const ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerTypeEnum = {
    DataRow: 'table_data_row',
    Header: 'table_header'
} as const;

export type ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerTypeEnum = typeof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerTypeEnum[keyof typeof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner
 */
export interface ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner {
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner
     */
    'cellValue': string;
    /**
     * 
     * @type {number}
     * @memberof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner
     */
    'colSpan': number | null;
    /**
     * 
     * @type {number}
     * @memberof ExtractPdfSuccessPagesInnerTablesInnerTableRowsInnerCellsInner
     */
    'rowSpan': number | null;
}
/**
 * 
 * @export
 * @interface ExtractPdfSuccessPagesInnerTextBlocksInner
 */
export interface ExtractPdfSuccessPagesInnerTextBlocksInner {
    /**
     * 
     * @type {string}
     * @memberof ExtractPdfSuccessPagesInnerTextBlocksInner
     */
    'kind': ExtractPdfSuccessPagesInnerTextBlocksInnerKindEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtractPdfSuccessPagesInnerTextBlocksInner
     */
    'texts': Array<string>;
}

export const ExtractPdfSuccessPagesInnerTextBlocksInnerKindEnum = {
    Footer: 'footer',
    Header: 'header',
    SectionTitle: 'section_title',
    Text: 'text',
    Title: 'title'
} as const;

export type ExtractPdfSuccessPagesInnerTextBlocksInnerKindEnum = typeof ExtractPdfSuccessPagesInnerTextBlocksInnerKindEnum[keyof typeof ExtractPdfSuccessPagesInnerTextBlocksInnerKindEnum];

/**
 * 
 * @export
 * @interface FineTuneModelBodyParams
 */
export interface FineTuneModelBodyParams {
    /**
     * 
     * @type {Array<FineTuneModelBodyParamsSamplesInner>}
     * @memberof FineTuneModelBodyParams
     */
    'samples': Array<FineTuneModelBodyParamsSamplesInner>;
}
/**
 * 
 * @export
 * @interface FineTuneModelBodyParamsSamplesInner
 */
export interface FineTuneModelBodyParamsSamplesInner {
    /**
     * 
     * @type {FineTuneModelBodyParamsSamplesInnerFineTuningParameters}
     * @memberof FineTuneModelBodyParamsSamplesInner
     */
    'fineTuningParameters'?: FineTuneModelBodyParamsSamplesInnerFineTuningParameters | null;
    /**
     * 
     * @type {FineTuneModelBodyParamsSamplesInnerInputs}
     * @memberof FineTuneModelBodyParamsSamplesInner
     */
    'inputs': FineTuneModelBodyParamsSamplesInnerInputs;
}
/**
 * 
 * @export
 * @interface FineTuneModelBodyParamsSamplesInnerFineTuningParameters
 */
export interface FineTuneModelBodyParamsSamplesInnerFineTuningParameters {
    /**
     * 
     * @type {number}
     * @memberof FineTuneModelBodyParamsSamplesInnerFineTuningParameters
     */
    'multiplier'?: number | null;
}
/**
 * 
 * @export
 * @interface FineTuneModelBodyParamsSamplesInnerInputs
 */
export interface FineTuneModelBodyParamsSamplesInnerInputs {
}
/**
 * 
 * @export
 * @interface FineTuneModelBodyParamsSamplesInnerInputsAnyOfInner
 */
export interface FineTuneModelBodyParamsSamplesInnerInputsAnyOfInner {
    /**
     * 
     * @type {boolean}
     * @memberof FineTuneModelBodyParamsSamplesInnerInputsAnyOfInner
     */
    'parseSpecialTokens'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FineTuneModelBodyParamsSamplesInnerInputsAnyOfInner
     */
    'trainable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FineTuneModelBodyParamsSamplesInnerInputsAnyOfInner
     */
    'value': string;
}
/**
 * @type FineTuneModelError
 * @export
 */
export type FineTuneModelError = CompleteModelErrorOneOf | CompleteModelErrorOneOf1 | CompleteModelErrorOneOf10 | CompleteModelErrorOneOf2 | CompleteModelErrorOneOf8 | FineTuneModelErrorOneOf | FineTuneModelErrorOneOf1;

/**
 * 
 * @export
 * @interface FineTuneModelErrorOneOf
 */
export interface FineTuneModelErrorOneOf {
    /**
     * 
     * @type {string}
     * @memberof FineTuneModelErrorOneOf
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FineTuneModelErrorOneOf
     */
    'type': FineTuneModelErrorOneOfTypeEnum;
}

export const FineTuneModelErrorOneOfTypeEnum = {
    ModelIncapableOfFineTuning: 'modelIncapableOfFineTuning'
} as const;

export type FineTuneModelErrorOneOfTypeEnum = typeof FineTuneModelErrorOneOfTypeEnum[keyof typeof FineTuneModelErrorOneOfTypeEnum];

/**
 * 
 * @export
 * @interface FineTuneModelErrorOneOf1
 */
export interface FineTuneModelErrorOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof FineTuneModelErrorOneOf1
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FineTuneModelErrorOneOf1
     */
    'type': FineTuneModelErrorOneOf1TypeEnum;
}

export const FineTuneModelErrorOneOf1TypeEnum = {
    NanLoss: 'nanLoss'
} as const;

export type FineTuneModelErrorOneOf1TypeEnum = typeof FineTuneModelErrorOneOf1TypeEnum[keyof typeof FineTuneModelErrorOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface FineTuneModelSuccess
 */
export interface FineTuneModelSuccess {
    /**
     * 
     * @type {number}
     * @memberof FineTuneModelSuccess
     */
    'numberOfTrainableTokens': number;
    /**
     * 
     * @type {number}
     * @memberof FineTuneModelSuccess
     */
    'sumLoss': number;
}
/**
 * 
 * @export
 * @interface GenerateAnswerBodyParams
 */
export interface GenerateAnswerBodyParams {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerBodyParams
     */
    'question': string;
    /**
     * 
     * @type {GenerateAnswerBodyParamsSource}
     * @memberof GenerateAnswerBodyParams
     */
    'source': GenerateAnswerBodyParamsSource;
}
/**
 * @type GenerateAnswerBodyParamsSource
 * @export
 */
export type GenerateAnswerBodyParamsSource = GenerateAnswerBodyParamsSourceOneOf | GenerateAnswerBodyParamsSourceOneOf1;

/**
 * The reference RAG that must be used to answer the question.
 * @export
 * @interface GenerateAnswerBodyParamsSourceOneOf
 */
export interface GenerateAnswerBodyParamsSourceOneOf {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerBodyParamsSourceOneOf
     */
    'collectionId': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerBodyParamsSourceOneOf
     */
    'type': GenerateAnswerBodyParamsSourceOneOfTypeEnum;
}

export const GenerateAnswerBodyParamsSourceOneOfTypeEnum = {
    Rag: 'rag'
} as const;

export type GenerateAnswerBodyParamsSourceOneOfTypeEnum = typeof GenerateAnswerBodyParamsSourceOneOfTypeEnum[keyof typeof GenerateAnswerBodyParamsSourceOneOfTypeEnum];

/**
 * The document that must be used to answer the question.
 * @export
 * @interface GenerateAnswerBodyParamsSourceOneOf1
 */
export interface GenerateAnswerBodyParamsSourceOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerBodyParamsSourceOneOf1
     */
    'type': GenerateAnswerBodyParamsSourceOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerBodyParamsSourceOneOf1
     */
    'value': string;
}

export const GenerateAnswerBodyParamsSourceOneOf1TypeEnum = {
    Document: 'document'
} as const;

export type GenerateAnswerBodyParamsSourceOneOf1TypeEnum = typeof GenerateAnswerBodyParamsSourceOneOf1TypeEnum[keyof typeof GenerateAnswerBodyParamsSourceOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface GenerateAnswerError
 */
export interface GenerateAnswerError {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GenerateAnswerSuccess
 */
export interface GenerateAnswerSuccess {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerSuccess
     */
    'answer': string;
    /**
     * 
     * @type {GenerateAnswerSuccessRagContext}
     * @memberof GenerateAnswerSuccess
     */
    'ragContext'?: GenerateAnswerSuccessRagContext;
}
/**
 * 
 * @export
 * @interface GenerateAnswerSuccessRagContext
 */
export interface GenerateAnswerSuccessRagContext {
    /**
     * 
     * @type {Array<GenerateAnswerSuccessRagContextDocumentsInner>}
     * @memberof GenerateAnswerSuccessRagContext
     */
    'documents': Array<GenerateAnswerSuccessRagContextDocumentsInner>;
}
/**
 * 
 * @export
 * @interface GenerateAnswerSuccessRagContextDocumentsInner
 */
export interface GenerateAnswerSuccessRagContextDocumentsInner {
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerSuccessRagContextDocumentsInner
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateAnswerSuccessRagContextDocumentsInner
     */
    'fileName': string;
}
/**
 * 
 * @export
 * @interface GenerateEmbeddingBodyParams
 */
export interface GenerateEmbeddingBodyParams {
    /**
     * 
     * @type {Array<GenerateEmbeddingBodyParamsInputsInner>}
     * @memberof GenerateEmbeddingBodyParams
     */
    'inputs': Array<GenerateEmbeddingBodyParamsInputsInner>;
}
/**
 * 
 * @export
 * @interface GenerateEmbeddingBodyParamsInputsInner
 */
export interface GenerateEmbeddingBodyParamsInputsInner {
    /**
     * 
     * @type {string}
     * @memberof GenerateEmbeddingBodyParamsInputsInner
     */
    'input': string;
}
/**
 * 
 * @export
 * @interface GenerateEmbeddingError
 */
export interface GenerateEmbeddingError {
    /**
     * 
     * @type {string}
     * @memberof GenerateEmbeddingError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GenerateEmbeddingSuccess
 */
export interface GenerateEmbeddingSuccess {
    /**
     * 
     * @type {Array<GenerateEmbeddingSuccessEmbeddingsInner>}
     * @memberof GenerateEmbeddingSuccess
     */
    'embeddings': Array<GenerateEmbeddingSuccessEmbeddingsInner>;
}
/**
 * 
 * @export
 * @interface GenerateEmbeddingSuccessEmbeddingsInner
 */
export interface GenerateEmbeddingSuccessEmbeddingsInner {
    /**
     * 
     * @type {Array<number>}
     * @memberof GenerateEmbeddingSuccessEmbeddingsInner
     */
    'embedding': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GenerateEmbeddingSuccessEmbeddingsInner
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface GetAudioTranscriptionError
 */
export interface GetAudioTranscriptionError {
    /**
     * 
     * @type {string}
     * @memberof GetAudioTranscriptionError
     */
    'message': string;
}
/**
 * @type GetAudioTranscriptionSuccess
 * @export
 */
export type GetAudioTranscriptionSuccess = GetAudioTranscriptionSuccessOneOf | GetAudioTranscriptionSuccessOneOf1;

/**
 * 
 * @export
 * @interface GetAudioTranscriptionSuccessOneOf
 */
export interface GetAudioTranscriptionSuccessOneOf {
    /**
     * 
     * @type {any}
     * @memberof GetAudioTranscriptionSuccessOneOf
     */
    'result': any | null;
    /**
     * 
     * @type {string}
     * @memberof GetAudioTranscriptionSuccessOneOf
     */
    'status': GetAudioTranscriptionSuccessOneOfStatusEnum;
}

export const GetAudioTranscriptionSuccessOneOfStatusEnum = {
    Cancelled: 'cancelled',
    Failed: 'failed',
    Pending: 'pending',
    PendingCancellation: 'pendingCancellation',
    Running: 'running'
} as const;

export type GetAudioTranscriptionSuccessOneOfStatusEnum = typeof GetAudioTranscriptionSuccessOneOfStatusEnum[keyof typeof GetAudioTranscriptionSuccessOneOfStatusEnum];

/**
 * 
 * @export
 * @interface GetAudioTranscriptionSuccessOneOf1
 */
export interface GetAudioTranscriptionSuccessOneOf1 {
    /**
     * 
     * @type {GetAudioTranscriptionSuccessOneOf1Result}
     * @memberof GetAudioTranscriptionSuccessOneOf1
     */
    'result': GetAudioTranscriptionSuccessOneOf1Result;
    /**
     * 
     * @type {string}
     * @memberof GetAudioTranscriptionSuccessOneOf1
     */
    'status': GetAudioTranscriptionSuccessOneOf1StatusEnum;
}

export const GetAudioTranscriptionSuccessOneOf1StatusEnum = {
    Succeeded: 'succeeded'
} as const;

export type GetAudioTranscriptionSuccessOneOf1StatusEnum = typeof GetAudioTranscriptionSuccessOneOf1StatusEnum[keyof typeof GetAudioTranscriptionSuccessOneOf1StatusEnum];

/**
 * 
 * @export
 * @interface GetAudioTranscriptionSuccessOneOf1Result
 */
export interface GetAudioTranscriptionSuccessOneOf1Result {
    /**
     * 
     * @type {string}
     * @memberof GetAudioTranscriptionSuccessOneOf1Result
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface GetModelError
 */
export interface GetModelError {
    /**
     * 
     * @type {string}
     * @memberof GetModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetModelSuccess
 */
export interface GetModelSuccess {
    /**
     * 
     * @type {string}
     * @memberof GetModelSuccess
     */
    'baseModelId': string;
    /**
     * 
     * @type {string}
     * @memberof GetModelSuccess
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetModelSuccess
     */
    'latestUpdateTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetModelSuccess
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetModelSuccess
     */
    'type': GetModelSuccessTypeEnum;
}

export const GetModelSuccessTypeEnum = {
    ModelAdapter: 'modelAdapter'
} as const;

export type GetModelSuccessTypeEnum = typeof GetModelSuccessTypeEnum[keyof typeof GetModelSuccessTypeEnum];

/**
 * 
 * @export
 * @interface GetRagCollectionError
 */
export interface GetRagCollectionError {
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetRagCollectionSuccess
 */
export interface GetRagCollectionSuccess {
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccess
     */
    'creationTime': string;
    /**
     * 
     * @type {Array<GetRagCollectionSuccessFilesInner>}
     * @memberof GetRagCollectionSuccess
     */
    'files': Array<GetRagCollectionSuccessFilesInner>;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccess
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccess
     */
    'latestUpdateTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccess
     */
    'name': string;
    /**
     * 
     * @type {ListRagCollectionsSuccessRagCollectionsInnerParser}
     * @memberof GetRagCollectionSuccess
     */
    'parser': ListRagCollectionsSuccessRagCollectionsInnerParser;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccess
     */
    'slug': GetRagCollectionSuccessSlugEnum;
}

export const GetRagCollectionSuccessSlugEnum = {
    BgeLarge: 'bge-large'
} as const;

export type GetRagCollectionSuccessSlugEnum = typeof GetRagCollectionSuccessSlugEnum[keyof typeof GetRagCollectionSuccessSlugEnum];

/**
 * 
 * @export
 * @interface GetRagCollectionSuccessFilesInner
 */
export interface GetRagCollectionSuccessFilesInner {
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccessFilesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccessFilesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetRagCollectionSuccessFilesInner
     */
    'status': GetRagCollectionSuccessFilesInnerStatusEnum;
}

export const GetRagCollectionSuccessFilesInnerStatusEnum = {
    Cancelled: 'cancelled',
    Failed: 'failed',
    Succeeded: 'succeeded',
    Pending: 'pending',
    PendingCancellation: 'pendingCancellation',
    Running: 'running'
} as const;

export type GetRagCollectionSuccessFilesInnerStatusEnum = typeof GetRagCollectionSuccessFilesInnerStatusEnum[keyof typeof GetRagCollectionSuccessFilesInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListEmbeddingsError
 */
export interface ListEmbeddingsError {
    /**
     * 
     * @type {string}
     * @memberof ListEmbeddingsError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListEmbeddingsSuccess
 */
export interface ListEmbeddingsSuccess {
    /**
     * 
     * @type {Array<ListEmbeddingsSuccessEmbeddingsModelsInner>}
     * @memberof ListEmbeddingsSuccess
     */
    'embeddingsModels': Array<ListEmbeddingsSuccessEmbeddingsModelsInner>;
}
/**
 * 
 * @export
 * @interface ListEmbeddingsSuccessEmbeddingsModelsInner
 */
export interface ListEmbeddingsSuccessEmbeddingsModelsInner {
    /**
     * 
     * @type {string}
     * @memberof ListEmbeddingsSuccessEmbeddingsModelsInner
     */
    'slug': ListEmbeddingsSuccessEmbeddingsModelsInnerSlugEnum;
}

export const ListEmbeddingsSuccessEmbeddingsModelsInnerSlugEnum = {
    BgeLarge: 'bge-large'
} as const;

export type ListEmbeddingsSuccessEmbeddingsModelsInnerSlugEnum = typeof ListEmbeddingsSuccessEmbeddingsModelsInnerSlugEnum[keyof typeof ListEmbeddingsSuccessEmbeddingsModelsInnerSlugEnum];

/**
 * 
 * @export
 * @interface ListModelsError
 */
export interface ListModelsError {
    /**
     * 
     * @type {string}
     * @memberof ListModelsError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListModelsSuccess
 */
export interface ListModelsSuccess {
    /**
     * 
     * @type {Array<ListModelsSuccessModelsInner>}
     * @memberof ListModelsSuccess
     */
    'models': Array<ListModelsSuccessModelsInner>;
}
/**
 * @type ListModelsSuccessModelsInner
 * @export
 */
export type ListModelsSuccessModelsInner = BaseModel | ModelAdapter;

/**
 * 
 * @export
 * @interface ListRagCollectionsError
 */
export interface ListRagCollectionsError {
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListRagCollectionsSuccess
 */
export interface ListRagCollectionsSuccess {
    /**
     * 
     * @type {Array<ListRagCollectionsSuccessRagCollectionsInner>}
     * @memberof ListRagCollectionsSuccess
     */
    'ragCollections': Array<ListRagCollectionsSuccessRagCollectionsInner>;
}
/**
 * 
 * @export
 * @interface ListRagCollectionsSuccessRagCollectionsInner
 */
export interface ListRagCollectionsSuccessRagCollectionsInner {
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'creationTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'latestUpdateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'name': string;
    /**
     * 
     * @type {ListRagCollectionsSuccessRagCollectionsInnerParser}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'parser': ListRagCollectionsSuccessRagCollectionsInnerParser;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInner
     */
    'slug': ListRagCollectionsSuccessRagCollectionsInnerSlugEnum;
}

export const ListRagCollectionsSuccessRagCollectionsInnerSlugEnum = {
    BgeLarge: 'bge-large'
} as const;

export type ListRagCollectionsSuccessRagCollectionsInnerSlugEnum = typeof ListRagCollectionsSuccessRagCollectionsInnerSlugEnum[keyof typeof ListRagCollectionsSuccessRagCollectionsInnerSlugEnum];

/**
 * @type ListRagCollectionsSuccessRagCollectionsInnerParser
 * @export
 */
export type ListRagCollectionsSuccessRagCollectionsInnerParser = ListRagCollectionsSuccessRagCollectionsInnerParserOneOf | ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1;

/**
 * 
 * @export
 * @interface ListRagCollectionsSuccessRagCollectionsInnerParserOneOf
 */
export interface ListRagCollectionsSuccessRagCollectionsInnerParserOneOf {
    /**
     * 
     * @type {number}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf
     */
    'chunkOverlap': number;
    /**
     * 
     * @type {number}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf
     */
    'chunkSize': number;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf
     */
    'parserType': ListRagCollectionsSuccessRagCollectionsInnerParserOneOfParserTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf
     */
    'windowSize': number;
}

export const ListRagCollectionsSuccessRagCollectionsInnerParserOneOfParserTypeEnum = {
    SentenceWindowNodeParser: 'sentenceWindowNodeParser'
} as const;

export type ListRagCollectionsSuccessRagCollectionsInnerParserOneOfParserTypeEnum = typeof ListRagCollectionsSuccessRagCollectionsInnerParserOneOfParserTypeEnum[keyof typeof ListRagCollectionsSuccessRagCollectionsInnerParserOneOfParserTypeEnum];

/**
 * 
 * @export
 * @interface ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1
 */
export interface ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1
     */
    'chunkOverlap': number;
    /**
     * 
     * @type {number}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1
     */
    'chunkSize': number;
    /**
     * 
     * @type {string}
     * @memberof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1
     */
    'parserType': ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1ParserTypeEnum;
}

export const ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1ParserTypeEnum = {
    SimpleNodeParser: 'simpleNodeParser'
} as const;

export type ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1ParserTypeEnum = typeof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1ParserTypeEnum[keyof typeof ListRagCollectionsSuccessRagCollectionsInnerParserOneOf1ParserTypeEnum];

/**
 * 
 * @export
 * @interface ModelAdapter
 */
export interface ModelAdapter {
    /**
     * 
     * @type {string}
     * @memberof ModelAdapter
     */
    'baseModelId': string;
    /**
     * 
     * @type {string}
     * @memberof ModelAdapter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelAdapter
     */
    'latestUpdateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ModelAdapter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelAdapter
     */
    'type': ModelAdapterTypeEnum;
}

export const ModelAdapterTypeEnum = {
    ModelAdapter: 'modelAdapter'
} as const;

export type ModelAdapterTypeEnum = typeof ModelAdapterTypeEnum[keyof typeof ModelAdapterTypeEnum];

/**
 * 
 * @export
 * @interface PersonalizeDocumentBodyParams
 */
export interface PersonalizeDocumentBodyParams {
    /**
     * The description of the audience that the document should be personalized for.
     * @type {string}
     * @memberof PersonalizeDocumentBodyParams
     */
    'audienceDescription': string;
    /**
     * The document that will be personalized.
     * @type {string}
     * @memberof PersonalizeDocumentBodyParams
     */
    'document': string;
}
/**
 * 
 * @export
 * @interface PersonalizeDocumentError
 */
export interface PersonalizeDocumentError {
    /**
     * 
     * @type {string}
     * @memberof PersonalizeDocumentError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PersonalizeDocumentSuccess
 */
export interface PersonalizeDocumentSuccess {
    /**
     * 
     * @type {string}
     * @memberof PersonalizeDocumentSuccess
     */
    'personalizedDocument': string;
}
/**
 * 
 * @export
 * @interface SentenceWindowNodeParser
 */
export interface SentenceWindowNodeParser {
    /**
     * 
     * @type {number}
     * @memberof SentenceWindowNodeParser
     */
    'chunkOverlap'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SentenceWindowNodeParser
     */
    'chunkSize'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SentenceWindowNodeParser
     */
    'parserType': SentenceWindowNodeParserParserTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SentenceWindowNodeParser
     */
    'windowSize'?: number | null;
}

export const SentenceWindowNodeParserParserTypeEnum = {
    SentenceWindowNodeParser: 'sentenceWindowNodeParser'
} as const;

export type SentenceWindowNodeParserParserTypeEnum = typeof SentenceWindowNodeParserParserTypeEnum[keyof typeof SentenceWindowNodeParserParserTypeEnum];

/**
 * 
 * @export
 * @interface SimpleNodeParser
 */
export interface SimpleNodeParser {
    /**
     * 
     * @type {number}
     * @memberof SimpleNodeParser
     */
    'chunkOverlap'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleNodeParser
     */
    'chunkSize'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleNodeParser
     */
    'parserType': SimpleNodeParserParserTypeEnum;
}

export const SimpleNodeParserParserTypeEnum = {
    SimpleNodeParser: 'simpleNodeParser'
} as const;

export type SimpleNodeParserParserTypeEnum = typeof SimpleNodeParserParserTypeEnum[keyof typeof SimpleNodeParserParserTypeEnum];

/**
 * 
 * @export
 * @interface SummarizeDocumentBodyParams
 */
export interface SummarizeDocumentBodyParams {
    /**
     * The document to summarize.
     * @type {string}
     * @memberof SummarizeDocumentBodyParams
     */
    'document': string;
    /**
     * Examples of how to summarize documents.
     * @type {Array<SummarizeDocumentBodyParamsExamplesInner>}
     * @memberof SummarizeDocumentBodyParams
     */
    'examples'?: Array<SummarizeDocumentBodyParamsExamplesInner> | null;
    /**
     * Roughly how long the summary should be.
     * @type {string}
     * @memberof SummarizeDocumentBodyParams
     */
    'length'?: SummarizeDocumentBodyParamsLengthEnum;
}

export const SummarizeDocumentBodyParamsLengthEnum = {
    Short: 'short',
    Medium: 'medium',
    Long: 'long'
} as const;

export type SummarizeDocumentBodyParamsLengthEnum = typeof SummarizeDocumentBodyParamsLengthEnum[keyof typeof SummarizeDocumentBodyParamsLengthEnum];

/**
 * 
 * @export
 * @interface SummarizeDocumentBodyParamsExamplesInner
 */
export interface SummarizeDocumentBodyParamsExamplesInner {
    /**
     * 
     * @type {string}
     * @memberof SummarizeDocumentBodyParamsExamplesInner
     */
    'document': string;
    /**
     * 
     * @type {string}
     * @memberof SummarizeDocumentBodyParamsExamplesInner
     */
    'summary': string;
}
/**
 * 
 * @export
 * @interface SummarizeDocumentError
 */
export interface SummarizeDocumentError {
    /**
     * 
     * @type {string}
     * @memberof SummarizeDocumentError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface SummarizeDocumentSuccess
 */
export interface SummarizeDocumentSuccess {
    /**
     * 
     * @type {string}
     * @memberof SummarizeDocumentSuccess
     */
    'summary': string;
}
/**
 * 
 * @export
 * @interface UploadFileError
 */
export interface UploadFileError {
    /**
     * 
     * @type {string}
     * @memberof UploadFileError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UploadFileSuccess
 */
export interface UploadFileSuccess {
    /**
     * 
     * @type {string}
     * @memberof UploadFileSuccess
     */
    'id': string;
}

/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes text to determine the emotional tone of the message.
         * @summary Sentiment analysis
         * @param {string} xGradientWorkspaceId 
         * @param {AnalyzeSentimentBodyParams} analyzeSentimentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeSentiment: async (xGradientWorkspaceId: string, analyzeSentimentBodyParams: AnalyzeSentimentBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('analyzeSentiment', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'analyzeSentimentBodyParams' is not null or undefined
            assertParamExists('analyzeSentiment', 'analyzeSentimentBodyParams', analyzeSentimentBodyParams)
            const localVarPath = `/blocks/analyze-sentiment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(analyzeSentimentBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an audio transcription job.
         * @summary Create audio transcription
         * @param {string} xGradientWorkspaceId 
         * @param {CreateAudioTranscriptionBodyParams} createAudioTranscriptionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudioTranscription: async (xGradientWorkspaceId: string, createAudioTranscriptionBodyParams: CreateAudioTranscriptionBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('createAudioTranscription', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'createAudioTranscriptionBodyParams' is not null or undefined
            assertParamExists('createAudioTranscription', 'createAudioTranscriptionBodyParams', createAudioTranscriptionBodyParams)
            const localVarPath = `/blocks/transcription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(createAudioTranscriptionBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extracts an entity from the document with the specified fields and types.
         * @summary Entity extraction
         * @param {string} xGradientWorkspaceId 
         * @param {ExtractEntityBodyParams} extractEntityBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractEntity: async (xGradientWorkspaceId: string, extractEntityBodyParams: ExtractEntityBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('extractEntity', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'extractEntityBodyParams' is not null or undefined
            assertParamExists('extractEntity', 'extractEntityBodyParams', extractEntityBodyParams)
            const localVarPath = `/blocks/extract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(extractEntityBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extracts content from the PDF.
         * @summary PDF extraction
         * @param {string} xGradientWorkspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractPdf: async (xGradientWorkspaceId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('extractPdf', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('extractPdf', 'file', file)
            const localVarPath = `/blocks/extract-pdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


            if (file !== undefined) {
              if (typeof file === 'object' && (file as any).type === 'file') {
                localVarFormParams.append('file', (file as any).contentStream as any, { knownLength: (file as any).fileSize });
              } else {
                localVarFormParams.append('file', file as any);
              }
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...(localVarFormParams as any).getHeaders?.(),
              ...((localVarFormParams as any).hasKnownLength() ? { 'Content-Length': (localVarFormParams as any).getLengthSync() } : {}),
              ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Answers questions using the provided context.
         * @summary Document question & answer
         * @param {string} xGradientWorkspaceId 
         * @param {GenerateAnswerBodyParams} generateAnswerBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAnswer: async (xGradientWorkspaceId: string, generateAnswerBodyParams: GenerateAnswerBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('generateAnswer', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'generateAnswerBodyParams' is not null or undefined
            assertParamExists('generateAnswer', 'generateAnswerBodyParams', generateAnswerBodyParams)
            const localVarPath = `/blocks/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(generateAnswerBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the result of the audio transcription job.
         * @summary Get audio transcription
         * @param {string} transcriptionId 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioTranscription: async (transcriptionId: string, xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transcriptionId' is not null or undefined
            assertParamExists('getAudioTranscription', 'transcriptionId', transcriptionId)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('getAudioTranscription', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/blocks/transcription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (transcriptionId !== undefined) {
                localVarQueryParameter['transcriptionId'] = transcriptionId;
            }

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Personalizes the document in a tone and style specific to the described target audience.
         * @summary Document personalization
         * @param {string} xGradientWorkspaceId 
         * @param {PersonalizeDocumentBodyParams} personalizeDocumentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personalizeDocument: async (xGradientWorkspaceId: string, personalizeDocumentBodyParams: PersonalizeDocumentBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('personalizeDocument', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'personalizeDocumentBodyParams' is not null or undefined
            assertParamExists('personalizeDocument', 'personalizeDocumentBodyParams', personalizeDocumentBodyParams)
            const localVarPath = `/blocks/personalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(personalizeDocumentBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a summary of the document using the provided guidance.
         * @summary Document summary
         * @param {string} xGradientWorkspaceId 
         * @param {SummarizeDocumentBodyParams} summarizeDocumentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summarizeDocument: async (xGradientWorkspaceId: string, summarizeDocumentBodyParams: SummarizeDocumentBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('summarizeDocument', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'summarizeDocumentBodyParams' is not null or undefined
            assertParamExists('summarizeDocument', 'summarizeDocumentBodyParams', summarizeDocumentBodyParams)
            const localVarPath = `/blocks/summarize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(summarizeDocumentBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Analyzes text to determine the emotional tone of the message.
         * @summary Sentiment analysis
         * @param {string} xGradientWorkspaceId 
         * @param {AnalyzeSentimentBodyParams} analyzeSentimentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeSentiment(xGradientWorkspaceId: string, analyzeSentimentBodyParams: AnalyzeSentimentBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeSentimentSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeSentiment(xGradientWorkspaceId, analyzeSentimentBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an audio transcription job.
         * @summary Create audio transcription
         * @param {string} xGradientWorkspaceId 
         * @param {CreateAudioTranscriptionBodyParams} createAudioTranscriptionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAudioTranscription(xGradientWorkspaceId: string, createAudioTranscriptionBodyParams: CreateAudioTranscriptionBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAudioTranscriptionSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAudioTranscription(xGradientWorkspaceId, createAudioTranscriptionBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Extracts an entity from the document with the specified fields and types.
         * @summary Entity extraction
         * @param {string} xGradientWorkspaceId 
         * @param {ExtractEntityBodyParams} extractEntityBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractEntity(xGradientWorkspaceId: string, extractEntityBodyParams: ExtractEntityBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractEntitySuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractEntity(xGradientWorkspaceId, extractEntityBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Extracts content from the PDF.
         * @summary PDF extraction
         * @param {string} xGradientWorkspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractPdf(xGradientWorkspaceId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractPdfSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractPdf(xGradientWorkspaceId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Answers questions using the provided context.
         * @summary Document question & answer
         * @param {string} xGradientWorkspaceId 
         * @param {GenerateAnswerBodyParams} generateAnswerBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAnswer(xGradientWorkspaceId: string, generateAnswerBodyParams: GenerateAnswerBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateAnswerSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAnswer(xGradientWorkspaceId, generateAnswerBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the result of the audio transcription job.
         * @summary Get audio transcription
         * @param {string} transcriptionId 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioTranscription(transcriptionId: string, xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioTranscriptionSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudioTranscription(transcriptionId, xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Personalizes the document in a tone and style specific to the described target audience.
         * @summary Document personalization
         * @param {string} xGradientWorkspaceId 
         * @param {PersonalizeDocumentBodyParams} personalizeDocumentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personalizeDocument(xGradientWorkspaceId: string, personalizeDocumentBodyParams: PersonalizeDocumentBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalizeDocumentSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personalizeDocument(xGradientWorkspaceId, personalizeDocumentBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a summary of the document using the provided guidance.
         * @summary Document summary
         * @param {string} xGradientWorkspaceId 
         * @param {SummarizeDocumentBodyParams} summarizeDocumentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async summarizeDocument(xGradientWorkspaceId: string, summarizeDocumentBodyParams: SummarizeDocumentBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SummarizeDocumentSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.summarizeDocument(xGradientWorkspaceId, summarizeDocumentBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Analyzes text to determine the emotional tone of the message.
         * @summary Sentiment analysis
         * @param {BlocksApiAnalyzeSentimentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeSentiment(requestParameters: BlocksApiAnalyzeSentimentRequest, options?: AxiosRequestConfig): AxiosPromise<AnalyzeSentimentSuccess> {
            return localVarFp.analyzeSentiment(requestParameters.xGradientWorkspaceId, requestParameters.analyzeSentimentBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an audio transcription job.
         * @summary Create audio transcription
         * @param {BlocksApiCreateAudioTranscriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudioTranscription(requestParameters: BlocksApiCreateAudioTranscriptionRequest, options?: AxiosRequestConfig): AxiosPromise<CreateAudioTranscriptionSuccess> {
            return localVarFp.createAudioTranscription(requestParameters.xGradientWorkspaceId, requestParameters.createAudioTranscriptionBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Extracts an entity from the document with the specified fields and types.
         * @summary Entity extraction
         * @param {BlocksApiExtractEntityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractEntity(requestParameters: BlocksApiExtractEntityRequest, options?: AxiosRequestConfig): AxiosPromise<ExtractEntitySuccess> {
            return localVarFp.extractEntity(requestParameters.xGradientWorkspaceId, requestParameters.extractEntityBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Extracts content from the PDF.
         * @summary PDF extraction
         * @param {BlocksApiExtractPdfRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractPdf(requestParameters: BlocksApiExtractPdfRequest, options?: AxiosRequestConfig): AxiosPromise<ExtractPdfSuccess> {
            return localVarFp.extractPdf(requestParameters.xGradientWorkspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * Answers questions using the provided context.
         * @summary Document question & answer
         * @param {BlocksApiGenerateAnswerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAnswer(requestParameters: BlocksApiGenerateAnswerRequest, options?: AxiosRequestConfig): AxiosPromise<GenerateAnswerSuccess> {
            return localVarFp.generateAnswer(requestParameters.xGradientWorkspaceId, requestParameters.generateAnswerBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the result of the audio transcription job.
         * @summary Get audio transcription
         * @param {BlocksApiGetAudioTranscriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioTranscription(requestParameters: BlocksApiGetAudioTranscriptionRequest, options?: AxiosRequestConfig): AxiosPromise<GetAudioTranscriptionSuccess> {
            return localVarFp.getAudioTranscription(requestParameters.transcriptionId, requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Personalizes the document in a tone and style specific to the described target audience.
         * @summary Document personalization
         * @param {BlocksApiPersonalizeDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personalizeDocument(requestParameters: BlocksApiPersonalizeDocumentRequest, options?: AxiosRequestConfig): AxiosPromise<PersonalizeDocumentSuccess> {
            return localVarFp.personalizeDocument(requestParameters.xGradientWorkspaceId, requestParameters.personalizeDocumentBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a summary of the document using the provided guidance.
         * @summary Document summary
         * @param {BlocksApiSummarizeDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summarizeDocument(requestParameters: BlocksApiSummarizeDocumentRequest, options?: AxiosRequestConfig): AxiosPromise<SummarizeDocumentSuccess> {
            return localVarFp.summarizeDocument(requestParameters.xGradientWorkspaceId, requestParameters.summarizeDocumentBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for analyzeSentiment operation in BlocksApi.
 * @export
 * @interface BlocksApiAnalyzeSentimentRequest
 */
export interface BlocksApiAnalyzeSentimentRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiAnalyzeSentiment
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {AnalyzeSentimentBodyParams}
     * @memberof BlocksApiAnalyzeSentiment
     */
    readonly analyzeSentimentBodyParams: AnalyzeSentimentBodyParams
}

/**
 * Request parameters for createAudioTranscription operation in BlocksApi.
 * @export
 * @interface BlocksApiCreateAudioTranscriptionRequest
 */
export interface BlocksApiCreateAudioTranscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiCreateAudioTranscription
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {CreateAudioTranscriptionBodyParams}
     * @memberof BlocksApiCreateAudioTranscription
     */
    readonly createAudioTranscriptionBodyParams: CreateAudioTranscriptionBodyParams
}

/**
 * Request parameters for extractEntity operation in BlocksApi.
 * @export
 * @interface BlocksApiExtractEntityRequest
 */
export interface BlocksApiExtractEntityRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiExtractEntity
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {ExtractEntityBodyParams}
     * @memberof BlocksApiExtractEntity
     */
    readonly extractEntityBodyParams: ExtractEntityBodyParams
}

/**
 * Request parameters for extractPdf operation in BlocksApi.
 * @export
 * @interface BlocksApiExtractPdfRequest
 */
export interface BlocksApiExtractPdfRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiExtractPdf
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {File}
     * @memberof BlocksApiExtractPdf
     */
    readonly file: File
}

/**
 * Request parameters for generateAnswer operation in BlocksApi.
 * @export
 * @interface BlocksApiGenerateAnswerRequest
 */
export interface BlocksApiGenerateAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiGenerateAnswer
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {GenerateAnswerBodyParams}
     * @memberof BlocksApiGenerateAnswer
     */
    readonly generateAnswerBodyParams: GenerateAnswerBodyParams
}

/**
 * Request parameters for getAudioTranscription operation in BlocksApi.
 * @export
 * @interface BlocksApiGetAudioTranscriptionRequest
 */
export interface BlocksApiGetAudioTranscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiGetAudioTranscription
     */
    readonly transcriptionId: string

    /**
     * 
     * @type {string}
     * @memberof BlocksApiGetAudioTranscription
     */
    readonly xGradientWorkspaceId: string
}

/**
 * Request parameters for personalizeDocument operation in BlocksApi.
 * @export
 * @interface BlocksApiPersonalizeDocumentRequest
 */
export interface BlocksApiPersonalizeDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiPersonalizeDocument
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {PersonalizeDocumentBodyParams}
     * @memberof BlocksApiPersonalizeDocument
     */
    readonly personalizeDocumentBodyParams: PersonalizeDocumentBodyParams
}

/**
 * Request parameters for summarizeDocument operation in BlocksApi.
 * @export
 * @interface BlocksApiSummarizeDocumentRequest
 */
export interface BlocksApiSummarizeDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof BlocksApiSummarizeDocument
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {SummarizeDocumentBodyParams}
     * @memberof BlocksApiSummarizeDocument
     */
    readonly summarizeDocumentBodyParams: SummarizeDocumentBodyParams
}

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Analyzes text to determine the emotional tone of the message.
     * @summary Sentiment analysis
     * @param {BlocksApiAnalyzeSentimentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public analyzeSentiment(requestParameters: BlocksApiAnalyzeSentimentRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).analyzeSentiment(requestParameters.xGradientWorkspaceId, requestParameters.analyzeSentimentBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an audio transcription job.
     * @summary Create audio transcription
     * @param {BlocksApiCreateAudioTranscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public createAudioTranscription(requestParameters: BlocksApiCreateAudioTranscriptionRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).createAudioTranscription(requestParameters.xGradientWorkspaceId, requestParameters.createAudioTranscriptionBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extracts an entity from the document with the specified fields and types.
     * @summary Entity extraction
     * @param {BlocksApiExtractEntityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public extractEntity(requestParameters: BlocksApiExtractEntityRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).extractEntity(requestParameters.xGradientWorkspaceId, requestParameters.extractEntityBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extracts content from the PDF.
     * @summary PDF extraction
     * @param {BlocksApiExtractPdfRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public extractPdf(requestParameters: BlocksApiExtractPdfRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).extractPdf(requestParameters.xGradientWorkspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Answers questions using the provided context.
     * @summary Document question & answer
     * @param {BlocksApiGenerateAnswerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public generateAnswer(requestParameters: BlocksApiGenerateAnswerRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).generateAnswer(requestParameters.xGradientWorkspaceId, requestParameters.generateAnswerBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the result of the audio transcription job.
     * @summary Get audio transcription
     * @param {BlocksApiGetAudioTranscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getAudioTranscription(requestParameters: BlocksApiGetAudioTranscriptionRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getAudioTranscription(requestParameters.transcriptionId, requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Personalizes the document in a tone and style specific to the described target audience.
     * @summary Document personalization
     * @param {BlocksApiPersonalizeDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public personalizeDocument(requestParameters: BlocksApiPersonalizeDocumentRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).personalizeDocument(requestParameters.xGradientWorkspaceId, requestParameters.personalizeDocumentBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a summary of the document using the provided guidance.
     * @summary Document summary
     * @param {BlocksApiSummarizeDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public summarizeDocument(requestParameters: BlocksApiSummarizeDocumentRequest, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).summarizeDocument(requestParameters.xGradientWorkspaceId, requestParameters.summarizeDocumentBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmbeddingsApi - axios parameter creator
 * @export
 */
export const EmbeddingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates normalized embeddings with the given embeddings model.
         * @summary Generate embeddings
         * @param {GenerateEmbeddingSlugEnum} slug 
         * @param {string} xGradientWorkspaceId 
         * @param {GenerateEmbeddingBodyParams} generateEmbeddingBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEmbedding: async (slug: GenerateEmbeddingSlugEnum, xGradientWorkspaceId: string, generateEmbeddingBodyParams: GenerateEmbeddingBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('generateEmbedding', 'slug', slug)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('generateEmbedding', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'generateEmbeddingBodyParams' is not null or undefined
            assertParamExists('generateEmbedding', 'generateEmbeddingBodyParams', generateEmbeddingBodyParams)
            const localVarPath = `/embeddings/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(generateEmbeddingBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the currently available embeddings models and provides basic information, such as the slug.
         * @summary List available embeddings models
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmbeddings: async (xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('listEmbeddings', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddingsApi - functional programming interface
 * @export
 */
export const EmbeddingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates normalized embeddings with the given embeddings model.
         * @summary Generate embeddings
         * @param {GenerateEmbeddingSlugEnum} slug 
         * @param {string} xGradientWorkspaceId 
         * @param {GenerateEmbeddingBodyParams} generateEmbeddingBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateEmbedding(slug: GenerateEmbeddingSlugEnum, xGradientWorkspaceId: string, generateEmbeddingBodyParams: GenerateEmbeddingBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateEmbeddingSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateEmbedding(slug, xGradientWorkspaceId, generateEmbeddingBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the currently available embeddings models and provides basic information, such as the slug.
         * @summary List available embeddings models
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmbeddings(xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEmbeddingsSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmbeddings(xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmbeddingsApi - factory interface
 * @export
 */
export const EmbeddingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddingsApiFp(configuration)
    return {
        /**
         * Generates normalized embeddings with the given embeddings model.
         * @summary Generate embeddings
         * @param {EmbeddingsApiGenerateEmbeddingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEmbedding(requestParameters: EmbeddingsApiGenerateEmbeddingRequest, options?: AxiosRequestConfig): AxiosPromise<GenerateEmbeddingSuccess> {
            return localVarFp.generateEmbedding(requestParameters.slug, requestParameters.xGradientWorkspaceId, requestParameters.generateEmbeddingBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the currently available embeddings models and provides basic information, such as the slug.
         * @summary List available embeddings models
         * @param {EmbeddingsApiListEmbeddingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmbeddings(requestParameters: EmbeddingsApiListEmbeddingsRequest, options?: AxiosRequestConfig): AxiosPromise<ListEmbeddingsSuccess> {
            return localVarFp.listEmbeddings(requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generateEmbedding operation in EmbeddingsApi.
 * @export
 * @interface EmbeddingsApiGenerateEmbeddingRequest
 */
export interface EmbeddingsApiGenerateEmbeddingRequest {
    /**
     * 
     * @type {'bge-large'}
     * @memberof EmbeddingsApiGenerateEmbedding
     */
    readonly slug: GenerateEmbeddingSlugEnum

    /**
     * 
     * @type {string}
     * @memberof EmbeddingsApiGenerateEmbedding
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {GenerateEmbeddingBodyParams}
     * @memberof EmbeddingsApiGenerateEmbedding
     */
    readonly generateEmbeddingBodyParams: GenerateEmbeddingBodyParams
}

/**
 * Request parameters for listEmbeddings operation in EmbeddingsApi.
 * @export
 * @interface EmbeddingsApiListEmbeddingsRequest
 */
export interface EmbeddingsApiListEmbeddingsRequest {
    /**
     * 
     * @type {string}
     * @memberof EmbeddingsApiListEmbeddings
     */
    readonly xGradientWorkspaceId: string
}

/**
 * EmbeddingsApi - object-oriented interface
 * @export
 * @class EmbeddingsApi
 * @extends {BaseAPI}
 */
export class EmbeddingsApi extends BaseAPI {
    /**
     * Generates normalized embeddings with the given embeddings model.
     * @summary Generate embeddings
     * @param {EmbeddingsApiGenerateEmbeddingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingsApi
     */
    public generateEmbedding(requestParameters: EmbeddingsApiGenerateEmbeddingRequest, options?: AxiosRequestConfig) {
        return EmbeddingsApiFp(this.configuration).generateEmbedding(requestParameters.slug, requestParameters.xGradientWorkspaceId, requestParameters.generateEmbeddingBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the currently available embeddings models and provides basic information, such as the slug.
     * @summary List available embeddings models
     * @param {EmbeddingsApiListEmbeddingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingsApi
     */
    public listEmbeddings(requestParameters: EmbeddingsApiListEmbeddingsRequest, options?: AxiosRequestConfig) {
        return EmbeddingsApiFp(this.configuration).listEmbeddings(requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GenerateEmbeddingSlugEnum = {
    BgeLarge: 'bge-large'
} as const;
export type GenerateEmbeddingSlugEnum = typeof GenerateEmbeddingSlugEnum[keyof typeof GenerateEmbeddingSlugEnum];


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stores uploaded file.
         * @summary File upload
         * @param {UploadFileTypeEnum} type 
         * @param {string} xGradientWorkspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (type: UploadFileTypeEnum, xGradientWorkspaceId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadFile', 'type', type)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('uploadFile', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


            if (file !== undefined) {
              if (typeof file === 'object' && (file as any).type === 'file') {
                localVarFormParams.append('file', (file as any).contentStream as any, { knownLength: (file as any).fileSize });
              } else {
                localVarFormParams.append('file', file as any);
              }
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...(localVarFormParams as any).getHeaders?.(),
              ...((localVarFormParams as any).hasKnownLength() ? { 'Content-Length': (localVarFormParams as any).getLengthSync() } : {}),
              ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Stores uploaded file.
         * @summary File upload
         * @param {UploadFileTypeEnum} type 
         * @param {string} xGradientWorkspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(type: UploadFileTypeEnum, xGradientWorkspaceId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(type, xGradientWorkspaceId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Stores uploaded file.
         * @summary File upload
         * @param {FilesApiUploadFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(requestParameters: FilesApiUploadFileRequest, options?: AxiosRequestConfig): AxiosPromise<UploadFileSuccess> {
            return localVarFp.uploadFile(requestParameters.type, requestParameters.xGradientWorkspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for uploadFile operation in FilesApi.
 * @export
 * @interface FilesApiUploadFileRequest
 */
export interface FilesApiUploadFileRequest {
    /**
     * 
     * @type {'audioFile' | 'ragUserFile'}
     * @memberof FilesApiUploadFile
     */
    readonly type: UploadFileTypeEnum

    /**
     * 
     * @type {string}
     * @memberof FilesApiUploadFile
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {File}
     * @memberof FilesApiUploadFile
     */
    readonly file: File
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Stores uploaded file.
     * @summary File upload
     * @param {FilesApiUploadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFile(requestParameters: FilesApiUploadFileRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadFile(requestParameters.type, requestParameters.xGradientWorkspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UploadFileTypeEnum = {
    AudioFile: 'audioFile',
    RagUserFile: 'ragUserFile'
} as const;
export type UploadFileTypeEnum = typeof UploadFileTypeEnum[keyof typeof UploadFileTypeEnum];


/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes your fine-tuned model with the specified prompt string. The model will generate a completion.
         * @summary Complete model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {CompleteModelBodyParams} completeModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeModel: async (id: string, xGradientWorkspaceId: string, completeModelBodyParams: CompleteModelBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeModel', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('completeModel', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'completeModelBodyParams' is not null or undefined
            assertParamExists('completeModel', 'completeModelBodyParams', completeModelBodyParams)
            const localVarPath = `/models/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(completeModelBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new instance of a model based on a specified model from the existing list.
         * @summary Create model
         * @param {string} xGradientWorkspaceId 
         * @param {CreateModelBodyParams} createModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel: async (xGradientWorkspaceId: string, createModelBodyParams: CreateModelBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('createModel', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'createModelBodyParams' is not null or undefined
            assertParamExists('createModel', 'createModelBodyParams', createModelBodyParams)
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(createModelBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the fine-tuned model.
         * @summary Delete model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (id: string, xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteModel', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('deleteModel', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fine-tunes the specified model with your data samples.
         * @summary Fine-tune model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {FineTuneModelBodyParams} fineTuneModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fineTuneModel: async (id: string, xGradientWorkspaceId: string, fineTuneModelBodyParams: FineTuneModelBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fineTuneModel', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('fineTuneModel', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'fineTuneModelBodyParams' is not null or undefined
            assertParamExists('fineTuneModel', 'fineTuneModelBodyParams', fineTuneModelBodyParams)
            const localVarPath = `/models/{id}/fine-tune`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(fineTuneModelBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Describes the specified model, including the model ID, name, and base model ID.
         * @summary Describe model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (id: string, xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getModel', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('getModel', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the currently available models in the selected workspace and provides basic information, such as the model name, ID and whether it is a base or fine-tuned model.
         * @summary List available models
         * @param {string} xGradientWorkspaceId 
         * @param {ListModelsCapabilityEnum} [capability] 
         * @param {boolean | null} [onlyBase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (xGradientWorkspaceId: string, capability?: ListModelsCapabilityEnum, onlyBase?: boolean | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('listModels', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (capability !== undefined) {
                localVarQueryParameter['capability'] = capability;
            }

            if (onlyBase !== undefined) {
                localVarQueryParameter['onlyBase'] = onlyBase;
            }

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes your fine-tuned model with the specified prompt string. The model will generate a completion.
         * @summary Complete model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {CompleteModelBodyParams} completeModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeModel(id: string, xGradientWorkspaceId: string, completeModelBodyParams: CompleteModelBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteModelSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeModel(id, xGradientWorkspaceId, completeModelBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new instance of a model based on a specified model from the existing list.
         * @summary Create model
         * @param {string} xGradientWorkspaceId 
         * @param {CreateModelBodyParams} createModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModel(xGradientWorkspaceId: string, createModelBodyParams: CreateModelBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateModelSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModel(xGradientWorkspaceId, createModelBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the fine-tuned model.
         * @summary Delete model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(id: string, xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(id, xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fine-tunes the specified model with your data samples.
         * @summary Fine-tune model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {FineTuneModelBodyParams} fineTuneModelBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fineTuneModel(id: string, xGradientWorkspaceId: string, fineTuneModelBodyParams: FineTuneModelBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineTuneModelSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fineTuneModel(id, xGradientWorkspaceId, fineTuneModelBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Describes the specified model, including the model ID, name, and base model ID.
         * @summary Describe model
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(id: string, xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetModelSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(id, xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the currently available models in the selected workspace and provides basic information, such as the model name, ID and whether it is a base or fine-tuned model.
         * @summary List available models
         * @param {string} xGradientWorkspaceId 
         * @param {ListModelsCapabilityEnum} [capability] 
         * @param {boolean | null} [onlyBase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(xGradientWorkspaceId: string, capability?: ListModelsCapabilityEnum, onlyBase?: boolean | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListModelsSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(xGradientWorkspaceId, capability, onlyBase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * Completes your fine-tuned model with the specified prompt string. The model will generate a completion.
         * @summary Complete model
         * @param {ModelsApiCompleteModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeModel(requestParameters: ModelsApiCompleteModelRequest, options?: AxiosRequestConfig): AxiosPromise<CompleteModelSuccess> {
            return localVarFp.completeModel(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.completeModelBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new instance of a model based on a specified model from the existing list.
         * @summary Create model
         * @param {ModelsApiCreateModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel(requestParameters: ModelsApiCreateModelRequest, options?: AxiosRequestConfig): AxiosPromise<CreateModelSuccess> {
            return localVarFp.createModel(requestParameters.xGradientWorkspaceId, requestParameters.createModelBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the fine-tuned model.
         * @summary Delete model
         * @param {ModelsApiDeleteModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(requestParameters: ModelsApiDeleteModelRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteModel(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fine-tunes the specified model with your data samples.
         * @summary Fine-tune model
         * @param {ModelsApiFineTuneModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fineTuneModel(requestParameters: ModelsApiFineTuneModelRequest, options?: AxiosRequestConfig): AxiosPromise<FineTuneModelSuccess> {
            return localVarFp.fineTuneModel(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.fineTuneModelBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Describes the specified model, including the model ID, name, and base model ID.
         * @summary Describe model
         * @param {ModelsApiGetModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(requestParameters: ModelsApiGetModelRequest, options?: AxiosRequestConfig): AxiosPromise<GetModelSuccess> {
            return localVarFp.getModel(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the currently available models in the selected workspace and provides basic information, such as the model name, ID and whether it is a base or fine-tuned model.
         * @summary List available models
         * @param {ModelsApiListModelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(requestParameters: ModelsApiListModelsRequest, options?: AxiosRequestConfig): AxiosPromise<ListModelsSuccess> {
            return localVarFp.listModels(requestParameters.xGradientWorkspaceId, requestParameters.capability, requestParameters.onlyBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeModel operation in ModelsApi.
 * @export
 * @interface ModelsApiCompleteModelRequest
 */
export interface ModelsApiCompleteModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiCompleteModel
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ModelsApiCompleteModel
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {CompleteModelBodyParams}
     * @memberof ModelsApiCompleteModel
     */
    readonly completeModelBodyParams: CompleteModelBodyParams
}

/**
 * Request parameters for createModel operation in ModelsApi.
 * @export
 * @interface ModelsApiCreateModelRequest
 */
export interface ModelsApiCreateModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiCreateModel
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {CreateModelBodyParams}
     * @memberof ModelsApiCreateModel
     */
    readonly createModelBodyParams: CreateModelBodyParams
}

/**
 * Request parameters for deleteModel operation in ModelsApi.
 * @export
 * @interface ModelsApiDeleteModelRequest
 */
export interface ModelsApiDeleteModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiDeleteModel
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ModelsApiDeleteModel
     */
    readonly xGradientWorkspaceId: string
}

/**
 * Request parameters for fineTuneModel operation in ModelsApi.
 * @export
 * @interface ModelsApiFineTuneModelRequest
 */
export interface ModelsApiFineTuneModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiFineTuneModel
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ModelsApiFineTuneModel
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {FineTuneModelBodyParams}
     * @memberof ModelsApiFineTuneModel
     */
    readonly fineTuneModelBodyParams: FineTuneModelBodyParams
}

/**
 * Request parameters for getModel operation in ModelsApi.
 * @export
 * @interface ModelsApiGetModelRequest
 */
export interface ModelsApiGetModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiGetModel
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ModelsApiGetModel
     */
    readonly xGradientWorkspaceId: string
}

/**
 * Request parameters for listModels operation in ModelsApi.
 * @export
 * @interface ModelsApiListModelsRequest
 */
export interface ModelsApiListModelsRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiListModels
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {'complete' | 'fineTune' | 'any'}
     * @memberof ModelsApiListModels
     */
    readonly capability?: ListModelsCapabilityEnum

    /**
     * 
     * @type {boolean}
     * @memberof ModelsApiListModels
     */
    readonly onlyBase?: boolean | null
}

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * Completes your fine-tuned model with the specified prompt string. The model will generate a completion.
     * @summary Complete model
     * @param {ModelsApiCompleteModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public completeModel(requestParameters: ModelsApiCompleteModelRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).completeModel(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.completeModelBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new instance of a model based on a specified model from the existing list.
     * @summary Create model
     * @param {ModelsApiCreateModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public createModel(requestParameters: ModelsApiCreateModelRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).createModel(requestParameters.xGradientWorkspaceId, requestParameters.createModelBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the fine-tuned model.
     * @summary Delete model
     * @param {ModelsApiDeleteModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public deleteModel(requestParameters: ModelsApiDeleteModelRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).deleteModel(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fine-tunes the specified model with your data samples.
     * @summary Fine-tune model
     * @param {ModelsApiFineTuneModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public fineTuneModel(requestParameters: ModelsApiFineTuneModelRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).fineTuneModel(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.fineTuneModelBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Describes the specified model, including the model ID, name, and base model ID.
     * @summary Describe model
     * @param {ModelsApiGetModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(requestParameters: ModelsApiGetModelRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).getModel(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the currently available models in the selected workspace and provides basic information, such as the model name, ID and whether it is a base or fine-tuned model.
     * @summary List available models
     * @param {ModelsApiListModelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public listModels(requestParameters: ModelsApiListModelsRequest, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(requestParameters.xGradientWorkspaceId, requestParameters.capability, requestParameters.onlyBase, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListModelsCapabilityEnum = {
    Complete: 'complete',
    FineTune: 'fineTune',
    Any: 'any'
} as const;
export type ListModelsCapabilityEnum = typeof ListModelsCapabilityEnum[keyof typeof ListModelsCapabilityEnum];


/**
 * RAGApi - axios parameter creator
 * @export
 */
export const RAGApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds files to the RAG collection.
         * @summary Add files to RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {AddFilesToRagCollectionBodyParams} addFilesToRagCollectionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToRagCollection: async (id: string, xGradientWorkspaceId: string, addFilesToRagCollectionBodyParams: AddFilesToRagCollectionBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addFilesToRagCollection', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('addFilesToRagCollection', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'addFilesToRagCollectionBodyParams' is not null or undefined
            assertParamExists('addFilesToRagCollection', 'addFilesToRagCollectionBodyParams', addFilesToRagCollectionBodyParams)
            const localVarPath = `/rag-collections/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(addFilesToRagCollectionBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new collection of RAG documents.
         * @summary Create RAG collection
         * @param {string} xGradientWorkspaceId 
         * @param {CreateRagCollectionBodyParams} createRagCollectionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRagCollection: async (xGradientWorkspaceId: string, createRagCollectionBodyParams: CreateRagCollectionBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('createRagCollection', 'xGradientWorkspaceId', xGradientWorkspaceId)
            // verify required parameter 'createRagCollectionBodyParams' is not null or undefined
            assertParamExists('createRagCollection', 'createRagCollectionBodyParams', createRagCollectionBodyParams)
            const localVarPath = `/rag-collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(createRagCollectionBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the RAG collection.
         * @summary Delete RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRagCollection: async (id: string, xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRagCollection', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('deleteRagCollection', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/rag-collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the RAG collection details.
         * @summary Get RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRagCollection: async (id: string, xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRagCollection', 'id', id)
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('getRagCollection', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/rag-collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all RAG collections associated with your workspace.
         * @summary List RAG collections
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRagCollections: async (xGradientWorkspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xGradientWorkspaceId' is not null or undefined
            assertParamExists('listRagCollections', 'xGradientWorkspaceId', xGradientWorkspaceId)
            const localVarPath = `/rag-collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xGradientWorkspaceId != null) {
                localVarHeaderParameter['x-gradient-workspace-id'] = String(xGradientWorkspaceId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
              ...localVarHeaderParameter,
              ...headersFromBaseOptions,
              ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RAGApi - functional programming interface
 * @export
 */
export const RAGApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RAGApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds files to the RAG collection.
         * @summary Add files to RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {AddFilesToRagCollectionBodyParams} addFilesToRagCollectionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFilesToRagCollection(id: string, xGradientWorkspaceId: string, addFilesToRagCollectionBodyParams: AddFilesToRagCollectionBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFilesToRagCollection(id, xGradientWorkspaceId, addFilesToRagCollectionBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new collection of RAG documents.
         * @summary Create RAG collection
         * @param {string} xGradientWorkspaceId 
         * @param {CreateRagCollectionBodyParams} createRagCollectionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRagCollection(xGradientWorkspaceId: string, createRagCollectionBodyParams: CreateRagCollectionBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRagCollectionSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRagCollection(xGradientWorkspaceId, createRagCollectionBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the RAG collection.
         * @summary Delete RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRagCollection(id: string, xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRagCollection(id, xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the RAG collection details.
         * @summary Get RAG collection
         * @param {string} id 
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRagCollection(id: string, xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRagCollectionSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRagCollection(id, xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all RAG collections associated with your workspace.
         * @summary List RAG collections
         * @param {string} xGradientWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRagCollections(xGradientWorkspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRagCollectionsSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRagCollections(xGradientWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RAGApi - factory interface
 * @export
 */
export const RAGApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RAGApiFp(configuration)
    return {
        /**
         * Adds files to the RAG collection.
         * @summary Add files to RAG collection
         * @param {RAGApiAddFilesToRagCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToRagCollection(requestParameters: RAGApiAddFilesToRagCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addFilesToRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.addFilesToRagCollectionBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new collection of RAG documents.
         * @summary Create RAG collection
         * @param {RAGApiCreateRagCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRagCollection(requestParameters: RAGApiCreateRagCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<CreateRagCollectionSuccess> {
            return localVarFp.createRagCollection(requestParameters.xGradientWorkspaceId, requestParameters.createRagCollectionBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the RAG collection.
         * @summary Delete RAG collection
         * @param {RAGApiDeleteRagCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRagCollection(requestParameters: RAGApiDeleteRagCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the RAG collection details.
         * @summary Get RAG collection
         * @param {RAGApiGetRagCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRagCollection(requestParameters: RAGApiGetRagCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<GetRagCollectionSuccess> {
            return localVarFp.getRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all RAG collections associated with your workspace.
         * @summary List RAG collections
         * @param {RAGApiListRagCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRagCollections(requestParameters: RAGApiListRagCollectionsRequest, options?: AxiosRequestConfig): AxiosPromise<ListRagCollectionsSuccess> {
            return localVarFp.listRagCollections(requestParameters.xGradientWorkspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFilesToRagCollection operation in RAGApi.
 * @export
 * @interface RAGApiAddFilesToRagCollectionRequest
 */
export interface RAGApiAddFilesToRagCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof RAGApiAddFilesToRagCollection
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof RAGApiAddFilesToRagCollection
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {AddFilesToRagCollectionBodyParams}
     * @memberof RAGApiAddFilesToRagCollection
     */
    readonly addFilesToRagCollectionBodyParams: AddFilesToRagCollectionBodyParams
}

/**
 * Request parameters for createRagCollection operation in RAGApi.
 * @export
 * @interface RAGApiCreateRagCollectionRequest
 */
export interface RAGApiCreateRagCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof RAGApiCreateRagCollection
     */
    readonly xGradientWorkspaceId: string

    /**
     * 
     * @type {CreateRagCollectionBodyParams}
     * @memberof RAGApiCreateRagCollection
     */
    readonly createRagCollectionBodyParams: CreateRagCollectionBodyParams
}

/**
 * Request parameters for deleteRagCollection operation in RAGApi.
 * @export
 * @interface RAGApiDeleteRagCollectionRequest
 */
export interface RAGApiDeleteRagCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof RAGApiDeleteRagCollection
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof RAGApiDeleteRagCollection
     */
    readonly xGradientWorkspaceId: string
}

/**
 * Request parameters for getRagCollection operation in RAGApi.
 * @export
 * @interface RAGApiGetRagCollectionRequest
 */
export interface RAGApiGetRagCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof RAGApiGetRagCollection
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof RAGApiGetRagCollection
     */
    readonly xGradientWorkspaceId: string
}

/**
 * Request parameters for listRagCollections operation in RAGApi.
 * @export
 * @interface RAGApiListRagCollectionsRequest
 */
export interface RAGApiListRagCollectionsRequest {
    /**
     * 
     * @type {string}
     * @memberof RAGApiListRagCollections
     */
    readonly xGradientWorkspaceId: string
}

/**
 * RAGApi - object-oriented interface
 * @export
 * @class RAGApi
 * @extends {BaseAPI}
 */
export class RAGApi extends BaseAPI {
    /**
     * Adds files to the RAG collection.
     * @summary Add files to RAG collection
     * @param {RAGApiAddFilesToRagCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGApi
     */
    public addFilesToRagCollection(requestParameters: RAGApiAddFilesToRagCollectionRequest, options?: AxiosRequestConfig) {
        return RAGApiFp(this.configuration).addFilesToRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, requestParameters.addFilesToRagCollectionBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new collection of RAG documents.
     * @summary Create RAG collection
     * @param {RAGApiCreateRagCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGApi
     */
    public createRagCollection(requestParameters: RAGApiCreateRagCollectionRequest, options?: AxiosRequestConfig) {
        return RAGApiFp(this.configuration).createRagCollection(requestParameters.xGradientWorkspaceId, requestParameters.createRagCollectionBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the RAG collection.
     * @summary Delete RAG collection
     * @param {RAGApiDeleteRagCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGApi
     */
    public deleteRagCollection(requestParameters: RAGApiDeleteRagCollectionRequest, options?: AxiosRequestConfig) {
        return RAGApiFp(this.configuration).deleteRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the RAG collection details.
     * @summary Get RAG collection
     * @param {RAGApiGetRagCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGApi
     */
    public getRagCollection(requestParameters: RAGApiGetRagCollectionRequest, options?: AxiosRequestConfig) {
        return RAGApiFp(this.configuration).getRagCollection(requestParameters.id, requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all RAG collections associated with your workspace.
     * @summary List RAG collections
     * @param {RAGApiListRagCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGApi
     */
    public listRagCollections(requestParameters: RAGApiListRagCollectionsRequest, options?: AxiosRequestConfig) {
        return RAGApiFp(this.configuration).listRagCollections(requestParameters.xGradientWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



